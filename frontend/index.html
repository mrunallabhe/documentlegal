<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>AI Crime Evidence Organizer</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 2rem;
        background: #0f172a;
        color: #f8fafc;
      }
      h1 {
        margin-bottom: 0.5rem;
      }
      section {
        background: #1e293b;
        border-radius: 12px;
        padding: 1.5rem;
        margin-bottom: 1.5rem;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
      }
      label,
      input,
      button,
      textarea {
        width: 100%;
        margin-top: 0.5rem;
        margin-bottom: 1rem;
      }
      button {
        padding: 0.75rem;
        border: none;
        border-radius: 6px;
        background: #38bdf8;
        color: #0f172a;
        font-weight: bold;
        cursor: pointer;
      }
      button:hover {
        background: #0ea5e9;
      }
      .grid {
        display: grid;
        gap: 1rem;
      }
      @media (min-width: 768px) {
        .grid {
          grid-template-columns: repeat(2, 1fr);
        }
      }
      textarea {
        min-height: 300px;
        background: #0f172a;
        color: #f8fafc;
        border: 1px solid #334155;
        border-radius: 6px;
        padding: 0.75rem;
        font-family: 'Courier New', monospace;
        font-size: 0.9rem;
        white-space: pre-wrap;
        word-wrap: break-word;
      }
      .content-section {
        margin-top: 1rem;
        padding: 1rem;
        background: #0f172a;
        border-radius: 6px;
        border: 1px solid #334155;
      }
      .content-section h3 {
        margin-top: 0;
        color: #38bdf8;
      }
      .entity-tag {
        display: inline-block;
        background: #1e40af;
        color: #fff;
        padding: 0.2rem 0.5rem;
        border-radius: 4px;
        margin: 0.2rem;
        font-size: 0.85rem;
      }
    </style>
  </head>
  <body>
    <h1>AI Crime Evidence Organizer</h1>
    <p>Upload evidence, trigger AI processing, and review reports.</p>

    <section>
      <h2>Upload & Process Evidence</h2>
      <form id="upload-form">
        <input type="file" id="file-input" accept=".pdf,.txt,.jpg,.jpeg,.png,.bmp,.tiff" />
        <button type="submit">Upload & Process</button>
      </form>
      <div id="status-message" style="margin-top: 1rem; padding: 1rem; background: #0f172a; border-radius: 6px; display: none;">
        <div id="status-text"></div>
        <div id="progress-bar" style="margin-top: 0.5rem; height: 4px; background: #334155; border-radius: 2px; overflow: hidden; display: none;">
          <div id="progress-fill" style="height: 100%; background: #38bdf8; width: 0%; transition: width 0.3s;"></div>
        </div>
      </div>
    </section>

    <section>
      <h2>Analysis Report</h2>
      <textarea id="report-output" readonly placeholder="Upload a file to see the analysis report. The system will automatically process it and display results here."></textarea>
    </section>

    <script>
      const API = "http://localhost:8000";

      function showStatus(message, showProgress = false) {
        const statusDiv = document.getElementById("status-message");
        const statusText = document.getElementById("status-text");
        const progressBar = document.getElementById("progress-bar");
        const progressFill = document.getElementById("progress-fill");
        
        statusText.textContent = message;
        statusDiv.style.display = "block";
        
        if (showProgress) {
          progressBar.style.display = "block";
          progressFill.style.width = "0%";
        } else {
          progressBar.style.display = "none";
        }
      }

      function updateProgress(percent) {
        const progressFill = document.getElementById("progress-fill");
        progressFill.style.width = percent + "%";
      }

      function formatReport(data) {
        // Validate data structure
        if (!data) {
          return "Error: No data received from server.";
        }
        
        let formattedReport = "=== AI CRIME EVIDENCE ORGANIZER REPORT ===\n\n";
        formattedReport += `Case ID: ${data.case_id || 'N/A'}\n`;
        
        // Handle generated_at - could be string or Date object
        let generatedDate = 'N/A';
        if (data.generated_at) {
          try {
            generatedDate = new Date(data.generated_at).toLocaleString();
          } catch (e) {
            generatedDate = String(data.generated_at);
          }
        }
        formattedReport += `Generated: ${generatedDate}\n`;
        formattedReport += `Timeline Events: ${data.timeline_events !== undefined ? data.timeline_events : 'N/A'}\n`;
        formattedReport += `Inconsistencies Found: ${data.inconsistencies !== undefined ? data.inconsistencies : 'N/A'}\n\n`;
        
        // Extracted Content
        if (data.preview && data.preview.extracted_content) {
          formattedReport += "=== EXTRACTED CONTENT ===\n\n";
          data.preview.extracted_content.forEach((content, idx) => {
            formattedReport += `--- Evidence Item ${idx + 1} ---\n`;
            formattedReport += `Type: ${content.file_type}\n`;
            formattedReport += `Classification: ${content.classification?.label || 'Unknown'} (${(content.classification?.confidence * 100 || 0).toFixed(1)}%)\n\n`;
            
            // Document Text
            if (content.extracted_text) {
              formattedReport += "EXTRACTED TEXT:\n";
              formattedReport += content.extracted_text.substring(0, 2000);
              if (content.extracted_text.length > 2000) {
                formattedReport += "\n... (truncated)";
              }
              formattedReport += "\n\n";
            }
            
            // OCR Text (from images)
            if (content.ocr_text) {
              formattedReport += "OCR TEXT (from image):\n";
              formattedReport += content.ocr_text.substring(0, 1000);
              if (content.ocr_text.length > 1000) {
                formattedReport += "\n... (truncated)";
              }
              formattedReport += "\n\n";
            }
            
            // Entities
            if (content.entities && content.entities.length > 0) {
              formattedReport += "ENTITIES FOUND:\n";
              content.entities.forEach(entity => {
                formattedReport += `  - ${entity.entity} (${entity.label})\n`;
              });
              formattedReport += "\n";
            }
            
            // Objects Detected (from images)
            if (content.objects_detected && content.objects_detected.length > 0) {
              formattedReport += "OBJECTS DETECTED:\n";
              content.objects_detected.forEach(obj => {
                formattedReport += `  - ${obj.class} (confidence: ${(obj.confidence * 100).toFixed(1)}%)\n`;
              });
              formattedReport += "\n";
            }
            
            // Timestamps
            if (content.timestamps && content.timestamps.length > 0) {
              formattedReport += "TIMESTAMPS FOUND:\n";
              content.timestamps.forEach(ts => {
                formattedReport += `  - ${ts}\n`;
              });
              formattedReport += "\n";
            }
            
            // Locations
            if (content.locations && content.locations.length > 0) {
              formattedReport += "LOCATIONS FOUND:\n";
              content.locations.forEach(loc => {
                formattedReport += `  - ${loc}\n`;
              });
              formattedReport += "\n";
            }
            
            formattedReport += "\n";
          });
        }
        
        // Case Summary (if available)
        if (data.preview && data.preview.case_summary) {
          formattedReport += "=== CASE SUMMARY ===\n\n";
          formattedReport += data.preview.case_summary;
          formattedReport += "\n\n";
        }
        
        // Structured Timeline
        if (data.preview && data.preview.timeline && Array.isArray(data.preview.timeline)) {
          formattedReport += "=== STRUCTURED TIMELINE ===\n\n";
          formattedReport += "Time          | Source      | Event                                    | Notes/Conflicts\n";
          formattedReport += "--------------|-------------|------------------------------------------|----------------\n";
          
          data.preview.timeline.forEach((item, idx) => {
            const time = item.time || item.timestamp || "N/A";
            const source = item.source || "Unknown";
            const event = item.event || item.description || "N/A";
            const notes = item.notes || "";
            
            // Format for table-like display
            const timeCol = (time + "          ").substring(0, 13);
            const sourceCol = (source + "           ").substring(0, 11);
            const eventCol = (event + "                                        ").substring(0, 40);
            const notesCol = notes.substring(0, 50);
            
            formattedReport += `${timeCol}| ${sourceCol}| ${eventCol}| ${notesCol}\n`;
          });
          formattedReport += "\n";
        } else if (data.preview && data.preview.timeline) {
          // Fallback to old format
          formattedReport += "=== TIMELINE ===\n\n";
          data.preview.timeline.forEach((event, idx) => {
            formattedReport += `${idx + 1}. ${event}\n`;
          });
          formattedReport += "\n";
        }
        
        // Inconsistencies
        if (data.preview && data.preview.inconsistencies && data.preview.inconsistencies.length > 0) {
          formattedReport += "=== INCONSISTENCIES DETECTED ===\n\n";
          data.preview.inconsistencies.forEach((inc, idx) => {
            formattedReport += `${idx + 1}. Type: ${inc.type || 'Unknown'}\n`;
            formattedReport += `   Details: ${inc.details || 'N/A'}\n`;
            if (inc.severity) {
              formattedReport += `   Severity: ${inc.severity}\n`;
            }
            formattedReport += "\n";
          });
        }
        
        // Missing Evidence
        if (data.missing_evidence && data.missing_evidence.length > 0) {
          formattedReport += "=== MISSING EVIDENCE SUGGESTIONS ===\n\n";
          data.missing_evidence.forEach((item, idx) => {
            formattedReport += `${idx + 1}. ${item}\n`;
          });
        }
        
        formattedReport += "\n=== END OF REPORT ===";
        return formattedReport;
      }

      document.getElementById("upload-form").addEventListener("submit", async (e) => {
        e.preventDefault();
        const fileInput = document.getElementById("file-input");
        if (!fileInput.files.length) {
          alert("Please select a file first");
          return;
        }

        const file = fileInput.files[0];
        showStatus("Uploading file...", true);
        updateProgress(10);

        try {
          // Step 1: Upload file
          const formData = new FormData();
          formData.append("file", file);
          
          showStatus("Uploading file...", true);
          updateProgress(20);
          
          const uploadRes = await fetch(`${API}/evidence/upload`, {
            method: "POST",
            body: formData
          });

          if (!uploadRes.ok) {
            throw new Error(`Upload failed: ${uploadRes.statusText}`);
          }

          const uploadData = await uploadRes.json();
          const caseId = uploadData.case_id;
          const artifactPath = uploadData.stored_path;

          showStatus("File uploaded. Processing with AI...", true);
          updateProgress(40);

          // Step 2: Process evidence (automatic)
          const processRes = await fetch(`${API}/evidence/process`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              case_id: caseId,
              artifact_path: artifactPath
            })
          });

          if (!processRes.ok) {
            throw new Error(`Processing failed: ${processRes.statusText}`);
          }

          showStatus("AI processing in progress... This may take 2-5 minutes on first run (downloading models)...", true);
          updateProgress(60);

          // Step 3: Wait for processing to complete (now synchronous, but we still poll for report)
          // Poll for report (check every 2 seconds, max 6 minutes for first-time model downloads)
          let attempts = 0;
          const maxAttempts = 180; // 180 attempts * 2 seconds = 6 minutes
          let reportData = null;

          while (attempts < maxAttempts) {
            await new Promise(resolve => setTimeout(resolve, 2000)); // Check every 2 seconds
            attempts++;
            const elapsedSeconds = attempts * 2;
            const progressPercent = Math.min(60 + (attempts * 0.2), 98); // Progress from 60% to 98%
            updateProgress(progressPercent);

            try {
              const reportRes = await fetch(`${API}/reports/${caseId}`);
              if (reportRes.ok) {
                const jsonData = await reportRes.json();
                // Debug: log the response
                console.log("Report API response:", jsonData);
                // Validate that we got valid data
                if (jsonData && (jsonData.case_id || jsonData.caseId)) {
                  // Handle both snake_case and camelCase
                  reportData = jsonData;
                  // Normalize case_id if needed
                  if (!reportData.case_id && reportData.caseId) {
                    reportData.case_id = reportData.caseId;
                  }
                  break;
                } else {
                  console.warn("Report data incomplete, waiting...", jsonData);
                  // If we got a response but it's incomplete, log it for debugging
                  if (jsonData) {
                    console.warn("Received data keys:", Object.keys(jsonData));
                  }
                }
              } else if (reportRes.status === 202) {
                // 202 Accepted = processing in progress, continue polling
                // Don't log this as an error, it's expected
              } else if (reportRes.status === 404) {
                // 404 = not started yet, continue polling
                // Don't log this as an error, it's expected
              } else {
                // Other error status - try to get error message
                const errorText = await reportRes.text();
                console.warn(`Report check returned status ${reportRes.status}:`, errorText);
              }
            } catch (err) {
              // Network error, continue polling
              // Don't log this as an error during polling
              console.warn("Network error during polling (expected):", err.message);
            }

            // Show elapsed time with helpful message
            const minutes = Math.floor(elapsedSeconds / 60);
            const seconds = elapsedSeconds % 60;
            let statusMsg = "";
            if (elapsedSeconds < 30) {
              statusMsg = `Processing started... (${elapsedSeconds}s)`;
            } else if (elapsedSeconds < 120) {
              statusMsg = `Processing... Models may be downloading (${minutes}m ${seconds}s)`;
            } else {
              statusMsg = `Still processing... First-time model download can take 3-5 minutes (${minutes}m ${seconds}s)`;
            }
            showStatus(statusMsg, true);
          }

          if (!reportData) {
            throw new Error("Report generation timed out after 6 minutes. The BERT model (440MB) may still be downloading. Please wait a bit longer and try refreshing, or check server logs.");
          }

          // Validate report data before formatting
          if (!reportData.case_id) {
            console.error("Invalid report data received:", reportData);
            throw new Error("Received invalid report data from server. Please check server logs.");
          }

          showStatus("Processing complete! Generating report...", true);
          updateProgress(100);

          // Step 4: Display formatted report
          console.log("Formatting report with data:", reportData);
          const formattedReport = formatReport(reportData);
          document.getElementById("report-output").value = formattedReport;

          showStatus("✅ Analysis complete! Report generated below.", false);
          
          // Hide progress after 3 seconds
          setTimeout(() => {
            document.getElementById("status-message").style.display = "none";
          }, 3000);

        } catch (error) {
          console.error("Full error:", error);
          showStatus(`❌ Error: ${error.message}`, false);
          const errorDetails = `Error: ${error.message}\n\nPlease try again or check:\n1. Server is running\n2. File format is supported (.pdf, .txt, .jpg, .png)\n3. File is not corrupted\n4. Check browser console (F12) for more details`;
          document.getElementById("report-output").value = errorDetails;
        }
      });
    </script>
  </body>
</html>

